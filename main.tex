%%
%% This is file `sample-acmsmall.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmsmall')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmsmall.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass
%% command.
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
\documentclass[acmsmall]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
	\providecommand\BibTeX{{%
			Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}


%%
%% These commands are for a JOURNAL article.
\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\begin{document}
	
	%%
	%% The "title" command has an optional parameter,
	%% allowing the author to define a "short title" to be used in page headers.
	\title{Uncomputation}
	
	%%
	%% The "author" command and its associated commands are used to define
	%% the authors and their affiliations.
	%% Of note is the shared affiliation of the first two authors, and the
	%% "authornote" and "authornotemark" commands
	%% used to denote shared contribution to the research.
	\author{Maisa Kirisame}
	\email{marisa@cs.utah.edu}
	\orcid{1234-5678-9012}
	\authornotemark[1]
	\affiliation{%
		\institution{University of Utah}
		\streetaddress{P.O. Box 1212}
		\city{Dublin}
		\state{Ohio}
		\country{USA}
		\postcode{43017-6221}
	}
	
	%%
	%% By default, the full list of authors will be used in the page
	%% headers. Often, this list is too long, and will overlap
	%% other information printed in the page headers. This command allows
	%% the author to define a more concise list
	%% of authors' names for this purpose.
	\renewcommand{\shortauthors}{Trovato et al.}
	
	%%
	%% The abstract is a short summary of the work to be presented in the
	%% article.
	\begin{abstract}
		Program execution need memory. Program may run out of memory for multiple reasons: big dataset, exploding intermediate state, the machine have less ram then others. When this happens, the program either get killed, or the operating system swaps, significantly degrading the performance.
		We proposing a technique, Uncomputation, that allow the program to continue running even after breaching the memory limit, without a significant performance degrade like the one introduced by swapping.
		Uncomputation work by turning computed values back into thunk, and upon needing the thunk, computing and storing them back.
		A naive implementation of uncomputation will face multiple problems. Among them, the most crucial and the most challenging one is breadcrumb. After a value is uncomputed, it's memory can be released but extra memory, breadcrumb, is needed to recompute the value back when needed.
		The smaller a value is, the breadcrumb it leave will take up a larger portion of memory, until the size of a value is less then or equal to that of the size of breadcrumb, in which uncomputing give no, or even negative memory benefit at all.
		The more value uncomputed, the more breadcrumb they leave behind, until most of the memory is used to record breadcrumb. This prohibit asymptotic improvement commonly seen in memory-cosntrainted algorithms.
		We present a runtime system, zombie, implemented as a library, that is absolved of the above breadcrumb problem, seemingly storing recompute information in 0-bits and violating information theory.
	\end{abstract}
	
	%%
	%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
	%% Please copy and paste the code instead of the example below.
	%%
		
	%%
	%% Keywords. The author(s) should pick words that accurately describe
	%% the work being presented. Separate the keywords with commas.
	\keywords{Do, Not, Us, This, Code, Put, the, Correct, Terms, for,
		Your, Paper}
	
	\received{20 February 2007}
	\received[revised]{12 March 2009}
	\received[accepted]{5 June 2009}
	
	%%
	%% This command processes the author and affiliation and title
	%% information and builds the first part of the formatted document.
	\maketitle
	
	\section{Introduction}
	Program use memory.
	
	Program may not have enough memory.
	
	Multiple reason:
	Huge input - opening a file of multiple gigabytes will hang editors
	
	Large intermediate state - model checker, chess bots, etc
	
	Small machine - poor people, embedded device
	
	Even if there is enough memory, still good to use less!
	Free up memory to run other process/increase cache size/give more room to garbage collectors.
	
	\section{Problems}
	How to measure size of a Value? (There is sharing)
	
	Partially evict a datastructure - how to reconnect
	
	What value to evict
	
	Breadcrumb
	
	\section{API}
	Zombie provide a monadic api.
	In particular, we exposed a type constructor, Zombie: * -> *,
	with the following 3 operations:
	
	return: X -> Zombie X

	bindN: Zombie X... -> (X... $\sim$> Zombie Y) -> Zombie Y

	get: Zombie X -> X
	
	the type Zombie externally speaking, behave as the Identity Monad - return and get is the identity, and bindN is the reversed apply. however, zombie will uncompute value behind the scene, recomputing them when needed, to save memory.
	
	two things worth noting:
	
	0 - we have a bindN, which take multiple Zombie, and a static function that does not capture any variable, from the inner type to another Zombie. This is different from the usual bindN accepting a single M, alongside a closured argument. This is because a closure will capture non-zombie values, so memory cannot be returned. Imagine the following function: M A -> M B -> M (A * B). An implementation via bind and return will capture A, causing said A to be non-evictable. note that bindN is of the same power as a closure allowing monadic bind.
	
	1 - the get function should only be used to obtain output, that will become a Zombie (or is used in a function that produce Zombie) again. This is because get strip out all metadata zombie maintain, so it is less efficient then obtaining the value via bindN.

	\section{Insight}
	There are multiple insights that allow us to solve the above 4 problems. Explaining them aid understanding the implementation of Zombie.
	
	0: treat each cell as independent, ignoring all member relationship.
	this trivialize size finding.
	
	1: hashconsing. to avoid the same expression producing multiple values, we introduce a type Idx, such that the same trace will be tagged with the same Idx.
	Zombie X hold Idx instead of X, and the actual values are stored in a datastructure.
	When return x try to create a Zombie X of tag idx, if idx is stored in the datastructure, that value is used instead, even though the computed value is equivalent to said value. This cause x to be immediately unreachable and can be released from memory. This allow evicting most of the list, only keeping some intermediate value. nowhere reachable via the object graph.
	
	2: note that bind can be nested: the function in bind may call more bind. When such nesting occur, executing the higher-level bind will also re-invoke the lower level bind. Hence - it is not necessary to store the lower-level thunk (even though doing so improve performance, as it will execute less code).
	
	With this in mind, if we can create a data structure imitating the bind/return execution of the program, we can remove non top-level nodes, so that lookup will return a higher-level result then the remove node, we solved the breadcrumb problem.
	
	\section{Tock Tree API}
	Below is an API summing up what we need.

	Tock = u64

	Range = Tock * Tock

	Make: TockTree X

	Insert: TockTree X -> Range * X -> ()

	Per two call to Insert, their range must either be nested or non-overlapping.

	Lookup: TockTree X -> Tock -> Option (Range * X)

	Remove: TockTree X -> Range -> ()

	\section{Implementation}
	Combining the 3 insights above we now sketch an implementation of Zombie.
	There is a global tock, which value begin from 0, increasing on every invocation of bind/return.
	A Zombie<X> hold an Integer, tock, instead of value of type X.
	The value is stored in the tock tree.
	Whenever a call to return or bind is finished, we put a Node onto the tock tree.
	The range of said node is the tock value at the begin and end of the invocation.
	
	For return, the node contain the value.
	
	For bind, the node contain the list of input Zombie, the output Zombie, and the function pointer.
	
	In bind, we have to force values from Zombie X to X. This is done via looking it up from the tock tree. If the look up node is not a Value, but the Thunk, we need to rewind the tock to the beginning of said thunk, replay the value, get the value from the tock tree (todo: avoid infinite loop here), and restore the tock.
	
	\subsection{replaying semantic}
	\section{Proof}
	
	\section{Cache Policy}
	
	\section{Eval}
	
	\section{OLD}
	All Zombies are threaded through a logical clock, a tock, stored as a u64.
	During execution, the clock increases whenever makeZombie and bindZombie are called.
	
	A Zombie contains, theoretically speaking, contains only the tock that the Zombie is created at.
	To access the actual value of the Zombie, a ZombieNode, we rely on a global data structure.
	It will be explained later.
	(We also store a weakpointer to ZombieNode as a cache, to quicken access. This is just a cache, and is irrelevant to the rest of Zombie).
	A ZombieNode holds X but is inherited from the Object class, which contain a virtual destructor and nothing else. This essentially allow one to type erase ZombieNode of different type, to put them into the same data structure.
	
	We implement Zombie via two global data structures, a log and a pool.
	The pool track all currently in-memory Zombie representation - it manage space
	The log record actions taken used for recomputation - it manage time
	
	The pool holds a vector of uniqueptr<Phantom>, the class that manage eviction.
	It has api to evict objects, and api to score the profitability of eviction.
	When we are low on memory, we can find a value in this vector, call evict(), and remove it.
	This will free up memory in the log.
	
	For every call to makeZombie and bindZombie, we keep track of when the function is called vs when the function exited. This establishes a tock range. 
	For makeZombie, since it does not call any more functions, its interval length is 1, containing exactly the tock of the zombie.
	Tock range overlap iff one contain another, iff one function calls another function. We then store tock range, paired with information on said function. 
	For makeZombie we store a shared pointer to the ZombieNode. 
	For bindZombie, we record the function used to compute it, as std::function<void(const std::vector<const void*>)>, alongside the tocks of all input Zombies, and the tock of output Zombie. We call it a Rematerializer. The input argument is type erased to void*, as Zombie is type polymorphic, but we need a type uniform interface here.
	
	The log is some kind of interval tree. Each node in the tree stores its begin and end interval, alongside a value, and a BST from tock to sub nodes. The key of BST is the start of the sub nodeâ€™s interval. When we query the log via a tock, we will find a value with the closest interval containing said tock. This mean, we might query for a Zombie, but instead of getting a ZombieNode, we get a Rematerializer.
	In such a case, we replay the Rematerializer by fetching the ZombieNode from the tock (replaying recursively if necessary), setting the clock to begin of the function temporarily, and entering said function. Afterward we set the clock back, and fetch the value from a tree.
	When we set the clock via rematerialization, we always set it to a smaller value, thus guaranteeing termination.
	
	The log itself, when replaying, also serve as a memo table, indexed by tock. When we want to create a Zombie, we will skip when such Zombie already exist in the log. When we want to run BindZombie, we return the result tock when the precise Rematerializer exist in the log. This allow us to not compute the same function multiple time, if we know its result, and allow us to not store the same Zombie multiple time.
	
	Note that all non-top-levels node in the tree can be removed. When we do so, we will free up memory, and when we need the value again, we can always replay a node higher up.
	
	This design allow us to store n log n amount of metadata per n alive(nonevicted) objects.
	
	Thus, when a Rematerializer dominate no value, and another value dominate Rematerializer, we remove it. (todo: implement). Idea: manage this using pool.
	
	There is a slight error with the above design: maybe the value is recomputed and put on the tree, but then evicted, and fetch will not return a ZombieNode but a Rematerializer. To fix this we introduce a global data structure called Tardis, consist of a tock and a shared ptr<ZombieNode>*. When we create Zombie, when the tock match that of tardis, it will write to the shared ptr, holding the value longer.
	
	Recursive object:
	Zombie allow recursive object, e.g. a list, a tree, or a graph.
	For those object, a part of the object can be evicted, and sharing does not affect size counting.
	This feature is implemented by ignoring recursiveness. All nesting need to loop through Zombie, and when it does that, the management of subsequent nested Zombie is completely handoff to it.
	Note that this allow keeping some value of the list in memory, even when there is previous node evicted!
	
%% If your work has an appendix, this is the place to put it.
\appendix
\end{document}
\endinput
%%
%% End of file `sample-acmsmall.tex'.

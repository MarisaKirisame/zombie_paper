\section{Uncomputing and Recomputing}
\subsection{Tock}
The key insight of Zombie is to introduce an abstraction layer between the executing program and the heap. This abstraction layer will allow the heap to transparently discard and recompute the program's intermediate values. To do so, we use the CEK machine to refer to each intermediate value by the index of the computation step that created it. Since each CEK step allocates at most one cell, this correspondence is injective. In other words, instead of storing pointers that refer to memory locations, we will store pointers, which we call ``tocks'', that refer to points in time---that is, CEK step indices.

In our runtime, these ``tocks'' are implemented as 64-bit integers, though in our model we will treat them as logically unbounded integers. There is a global ``current tock'' counter, which starts at 0 and is increased by 1 at every transition step in the abstract machine and at every allocation. The cell allocated at step $i$ is then referred to by the tock $i$, and that tock can then be used as a pointer, stored in data structures, looked up by later computations steps, and the like.

Note that, due to the determinism and linearity of the CEK machine, tocks are strictly ordered and the value computed at some tock $i$ can only depend on values computed at earlier tocks. Moreover we can recreate the value at tock $i$ by merely rerunning the CEK machine from some earlier state to that point. Because the CEK machine is deterministic, this re-execution will produce the same exact value as the original. Because our pointers refer to abstract values, not to specific memory locations, the heap can thus re-compute a value as necessary instead of storing it in memory.

In other words, the way Zombie works is that the heap will store only some of the intermediate values. The ones that aren't stored will instead be recomputed as needed, and the heap will store earlier CEK machine states in order to facilitate that. As the program runs, intermediate values can be discarded from the heap to reduce its memory usage.

Because a value can be recomputed from \emph{any} earlier CEK machine state, it will also turn out to be possible to store relatively few machine states. Therefore, overall memory usage---for the stored intermediate values and the stored machine states---can be kept low. In Zombie, we can store asymptotically fewer machine states than intermediate values, allowing us to asymptotically reduce memory usage.

\subsection{Tock Tree}
In Zombie, the heap is implemented by a runtime data structure called the tock tree. The tock tree maps tocks to the cells allocated by that step; in other words, the tock tree implements the mapping between tocks and their actual memory locations. Because values can be evicted to save memory, however, not all tocks have a mapping in the tock tree. Instead, every tock that \emph{is} present in the tock tree will also store its machine state. To recompute an evicted value at some tock $i$, the tock tree will find the largest machine state at tock $j < i$ and replay from that tock to tock $i$.

Each node in the Tock Tree stores both a memory cell and a machine state. Specifically, consider the execution of the CEK machine from step $t$. In step $t + 1$ it allocates a cell; it then performs a computation in step $t + 2$. So the node at tock $t$ contains both the cell allocated at step $t + 1$ as well as the machine state \emph{afterwards}, at step $t + 2$. A transition might not alloc any new cells, in such a case the Node only store a machine state any no memory cell. To be more specific, if the node represent the execution of the CEK machine at step $t$, it will only contain the CEK machine state at step $t + 1$.

In order to make this operation efficient, the tock tree is organized as a binary search tree. In a binary search tree, arbitrary keys (tocks) can be looked up in $O(\log(n))$ time, where $n$ is the size of the tock tree, and when a key is not found, the largest key smaller than it can be easily found. Then the heap can replay execution from that point to compute the desired tock.

\begin{figure}
	\includegraphics[width=0.5\columnwidth]{2}
	\caption{a node in the tock tree}
\end{figure}
\begin{figure}
	\includegraphics[width=0.5\columnwidth]{3}
	\caption{the tock tree with multiple nodes}
\end{figure}

\begin{figure}
	\includegraphics[width=0.5\columnwidth]{4}
	\caption{lookup failure return the latest earlier node}
\end{figure}

\subsection{Replay Continuation}
In order to replay for a cell at a tock t, we need to store
\begin{enumerate}
	\item the tock t that we replay to, so we can stop once the value correspond to t is found
	\item the original state before replaying, to resume execution at that poin
\end{enumerate} , so we can stop once t is found, and the original state before replaying, so we can resume execution at that point. 
This is essentially a continuation, which we called the replay continuation (RK).

Note that it is different from the normal continuation in the following way:
\begin{enumerate}
	\item continuation is a expr with a hole of type expr, while replay continuation is a state with a hole of type cell
	\item there are way less replay continuation type then continuation: this is because only the state that lookup a cell need a replay continuation; state that does not do not need replay, and so do not need replay continuation.
\end{enumerate}

Note that, during the replaying process, more lookup might be issued, and those lookup might need more replay - replay is recursive. Just like the classical continuation at the CEK machine, the Replay Continuation need to be recursive, and form a stack as well.

\subsection{CEKR Machine}
With the idea of tock, tock tree, and the replay continuation, we can now define an abstract machine, the CEKR Machine, that can uncompute and replay values.

The CEKR Machine consist of 6 parts:
\begin{enumerate}
	\item \textcolor{blue}{C}ontrol, the expression currently being evaluated.
	\item \textcolor{blue}{E}nvironment, a map from the free variables of the Control to their values.
	\item \textcolor{blue}{K}ontinuation, which is to be invoked with the value the Control evaluates to.
	\item \textcolor{blue}{R}eplay, the replay continuation.
	\item The current tock
	\item The tock tree
\end{enumerate}
And now have 3 modes: in addition to the eval and apply mode, there is a 'return' mode that hold only a cell.

Alongside the 3 modes come 3 kinds of transition:
\begin{enumerate}
	\item The happy path: the lookup in the CEK transition rule, is converted into the query transition rule. If the query is successful (the return tock is the queried tock), we enter the happy path, where the transition closely mirror that of the CEK-transition. We collect the cell allocated during transition, alongside the transit-to state, into a node, and insert it into the tock tree. We then transit-to the transit-to state specified by the CEK machine. However, if the tock matching the return continuation is allocated, the machine enter a returning mode instead.
	\item The sad path: on a query that failed(did not get the node matching the tock in return), replay is needed. To replay a value, we push the old state alongside the request tock onto the replay continuation, and transit to the state in the node.
	\item The return path: once a cell matching the top of the replay continuation is found,from the return mode, pop from the replay continuation to resume the state. It will then behave like a normal transition, as we obtained a cell by replaying, and no longer need to query the tock tree. \todo{bad wording dont know how to fix}
\end{enumerate}

\subsection{Reified Continuation}
We treat continuations also as values, and label them with tock/put them in the tock tree, just like any other values. This allow us to also uncompute continuation as well.

\subsection{Eviction}
This allow us to remove any non-leftmost node from the tock tree. After the removal, the query that originally return the removed node, will return the node slightly earlier then that, which we can then replay to regenerate the removed node. In fact, this is the implementation of uncomputation in our system, and any non-leftmost node can be removed, to save memory at any given time.
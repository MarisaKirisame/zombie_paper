\section{Uncomputation(5pg)}
\subsection{Motivation}
\subsection{Strawman}
\subsubsection{API}
Zombie provide a monadic api.
In particular, we exposed a type constructor, Zombie: * -> *,
with the following 3 operations:

return: X -> Zombie X

bindN: Zombie X... -> (X... $\sim$> Zombie Y) -> Zombie Y

get: Zombie X -> X

the type Zombie externally speaking, behave as the Identity Monad - return and get is the identity, and bindN is the reversed apply. however, zombie will uncompute value behind the scene, recomputing them when needed, to save memory.

two things worth noting:

0 - we have a bindN, which take multiple Zombie, and a static function that does not capture any variable, from the inner type to another Zombie. This is different from the usual bindN accepting a single M, alongside a closured argument. This is because a closure will capture non-zombie values, so memory cannot be returned. Imagine the following function: M A -> M B -> M (A * B). An implementation via bind and return will capture A, causing said A to be non-evictable. note that bindN is of the same power as a closure allowing monadic bind.

1 - the get function should only be used to obtain output, that will become a Zombie (or is used in a function that produce Zombie) again. This is because get strip out all metadata zombie maintain, so it is less efficient then obtaining the value via bindN.

\subsubsection{Semantic}
\subsection{Guarantee}
\subsection{Problems}
While the high-level idea seems straightforward, there are multiple subtle questions: 
\begin{itemize}
	\item Recursiveness. A value, for example, a list, might be recursive. Furthermore, there might be sharing inside such datastructure. In such a case, how do we measure the size of a value, which is a valuable statistics guiding what to uncompute?
	\item Partialness. Suppose a list is generated via anamorphism. We might want to uncompute the head of the list, but keeping some intermediate node inside the list.
	When recomputing said list, we need to be able to retrieve such intermediate node, to
	avoid spending extra time to recompute them, and extra memory to store them twice.
	\item Uncomputation candidates. Which value should we pick to uncompute?
	\item Breadcrumb. After a value is uncomputed, we need to store information needed to recompute said value. This become a bottleneck when most value is uncomputed, or when each value is small.
\end{itemize}

We present Zombie, a library for uncomptuation, alongside solutions to the questions above.
\subsubsection{recursiveness}
\subsubsection{doppelganger}
\subsubsection{breadcrumb}

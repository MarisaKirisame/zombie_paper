\section{Uncomputation(5pg)}
\subsection{Motivation}
\subsection{Strawman}
\subsubsection{API}
\todo{unable to use the monadic api.}
\subsubsection{Semantic}
\subsection{Guarantee}
\subsection{Problems}
While the high-level idea seems straightforward, there are multiple subtle questions: 
\begin{itemize}
	\item Recursiveness. A value, for example, a list, might be recursive. Furthermore, there might be sharing inside such datastructure. In such a case, how do we measure the size of a value, which is a valuable statistics guiding what to uncompute?
	\item Partialness. Suppose a list is generated via anamorphism. We might want to uncompute the head of the list, but keeping some intermediate node inside the list.
	When recomputing said list, we need to be able to retrieve such intermediate node, to
	avoid spending extra time to recompute them, and extra memory to store them twice.
	\item Uncomputation candidates. Which value should we pick to uncompute?
	\item Breadcrumb. After a value is uncomputed, we need to store information needed to recompute said value. This become a bottleneck when most value is uncomputed, or when each value is small.
\end{itemize}

We present Zombie, a library for uncomptuation, alongside solutions to the questions above.
\subsubsection{recursiveness}
\subsubsection{doppelganger}
\subsubsection{breadcrumb}

\section{CEKR Machine}
In this section we formalize the semantic of the language with uncomputation and recomputation. It is implemented by adding a Replay Continuation alongside the CEK Machine.
Hence we call it the CEKR Machine.

\subsection{Tock Tree}
\begin{figure}
	\begin{tabular}{p{6em} p{2.6em} p{7em} p{1em} p{0.45\textwidth}}
	before & $:$ & Value & = & P<VCell> \\
	after & $:$ & Value & = & Tock \\
	before & $:$ & Continuation & = & P<KCell> \\
	after & $:$ & Continuation & = & Tock \\
	before & $:$ & State & ::= & $\Step~E~\Env~K \mid \Apply~K~V $ \\
	after & $:$ & State & ::= & $\Step~E~\Env~K~Tock \mid \Apply~K~V~Tock $ \\
	Node & & & = & ([KCell | VCell], State) \\
	query & $:$ & (TockTree, Tock) & -> & (Tock, Node) \\
	insert & $:$ & (TockTree, Node) & -> & TockTree \\
	\end{tabular}
	\caption{Tock Tree API. Note that we deliberately avoid dictating what node get uncomputed, in order to decouple uncomputation/recomputation with selecting what to uncompute. Instead, node might be dropped during insertion into TockTree. One might e.g. set a limit onto the amount of nodes in the Tock Tree. }
\end{figure}

\subsection{Replay Continuation}
	\begin{tabular}{p{10em} p{2.6em} p{1em} p{0.45\textwidth}}
	ReplayContinuation & RK & ::= & NoReplay | RKApply V Tock RK | \\
	& & & RKCase Tock Env N E N E K RK | \\
	& & & RKZro Tock K RK | RKFst Tock K RK \\
	Replay & R & ::= & (State, RK) \\
\end{tabular}
\begin{mathpar}
	

	
	RApply: ((Tock, Node), RK) -> (State, RK)
	RApply((_, (cells, st)), NoReplay) = (st, NoReplay)
	RApply((t, (cells, st)), RKApply v t' rk) = if t + 1 <= t' < t + 1 + len(cells) then (Apply v cells[t' - t - 1] t', rk) else (st, RKApply v t' rk)
	RApply((t, (cells, st)), RKCase t' Env LN L RN R K RK) = if t + 1 <= t' < t + 1 + len(cells) then if cells[t' - t - 1] = VLeft X then ((Step L Env[LN := X] K, t'), rk) else if cells[t' - t - 1] = VRight Y then (Step R Env[RN := Y] K t', rk) else (st, RKCase t' Env LN L RN R K)
	RApply((t, (cells, st)), RKZro t' K) = if t + 1 <= t' < t + 1 + len(cells) then if cells[t' - t - 1] = VProd X Y then (Apply X K t', RK) else (st, RKZro t' K)
	RApply((t, (cells, st)), RKFst t' K) = if t + 1 <= t' < t + 1 + len(cells) then if cells[t' - t - 1] = VProd X Y then (Apply Y K t', RK) else (st, RKFst t' K)
\end{mathpar}

\begin{mathpar}
	FromTock: (TockTree, Tock) -> VCell | KCell | State
	From The tock tree, try to get the corresponding cell.
	If the cell is uncomputed, return the closest state that can recompute it.
	
	FromTock(tt, t) = 
	let (Node cells state, nt) = query(tt, t) in
	if nt + 1 <= t < nt + 1 + len(cells) then cells[t - nt - 1] else state
	
	goto: (Replay, TockTree) -> (Replay, TockTree)
	State = Step Expr Env K | Apply K V
	
	Step(N, Env, K), H goto apply(K, Env(N)), H
	
	Step(Left X, Env, K), H goto Step(X, Env, P), H' where (P, H') = Alloc(KLeft K, H)
	
	Step(Right X, Env, K), H goto Step(X, Env, P), H' where (P, H') = Alloc(KRight K, H)
	
	Step(Case X LN L RN R, Env, K), H goto Step(X, Env, P), H' where (P, H') = Alloc(KCase LN L RN R Env, H)
	
	Step(Prod L R, Env, K), H goto Step(L, Env, P), H' where (P, H') = Alloc(KProd0 K R, H)
	
	Step(Zro X, Env, K), H goto Step(X, Env, P), H' where (P, H') = Alloc(KZro K, H)
	
	Step(Fst X, Env, K), H goto Step(X, Env, P), H' where (P, H') = Alloc(KFst K, H)
	
	Step(Let A = B in C, Env, K), H goto Step(B, Env, P), H' where (P, H') = Alloc(KLet A K C Env, H)
	
	Step(App f x, Env, K), H goto Step(f, P), H' where (P, H') = Alloc(KApp0 K x, H)
	
	Step(Lam N E, Env, K), H goto Apply(K, P), H' where (P, H') = Alloc(Clos Env(fv)... N E, H)
\end{mathpar}
\begin{mathpar}
	Apply(P, V) = apply(Lookup(P), V)
	apply(KLeft K, V), H goto Apply(K, P), H' where (P, H') = Alloc(VLeft V, H)
	
	apply(KRight K, V), H goto Apply(K, P), H' where (P, H') = Alloc(VRight V, H)
	
	apply(KCase Env LN L RN R K, V), H goto 
	if LookUp(V, H) = VLeft V then Step(L, Env(LN := V), K)
	= VRight V then Step(R, Env(RN := V), K)
	
	apply(KProd0 Env R K, V), H goto Step(R, Env, P), H' where (P, H') = Alloc(KProd1 V Env K, H)
	
	apply(KProd1 L K, V), H goto Apply(P, K), H' where (P, H') = Alloc(VProd L V, H)
	
	apply(KZro K, V), H goto Apply(X, K), H where VProd X Y = LookUp(V, H)
	
	apply(KFst K, V), H goto Apply(Y, K), H where VProd X Y = LookUp(V, H)
	
	apply(KLet A Env C K, B), H goto Step(C, Env(A := B), K), H
	
	apply(KApp0 Env X K, V) goto Step(X, Env, P) where (P, H'), H' = Alloc(KApp1 V K, H)
	
	apply(KApp1 F K, V), H goto Step(E, Env(N := V), K), H where (Clos Env N E) = LookUp(V, H)
\end{mathpar}
\section{CEKR Machine}
In this section we formalize the semantic of the language with uncomputation and recomputation. It is implemented by adding a Replay Continuation alongside the CEK Machine.
Hence we call it the CEKR Machine.

\subsection{Tock Tree}
\begin{figure}
	\begin{tabular}{p{6em} p{2.6em} p{7em} p{1em} p{0.45\textwidth}}
	before & $:$ & Value & = & P<VCell> \\
	after & $:$ & Value & = & Tock \\
	before & $:$ & Continuation & = & P<KCell> \\
	after & $:$ & Continuation & = & Tock \\
	before & $:$ & State & ::= & $\Eval~E~\Env~K \mid \Apply~K~V $ \\
	after & $:$ & State & ::= & $\Eval~E~\Env~K~Tock \mid \Apply~K~V~Tock $ \\
	Node & & & = & ([KCell | VCell], State) \\
	query & $:$ & (TockTree, Tock) & -> & (Tock, Node) \\
	insert & $:$ & (TockTree, Node) & -> & TockTree \\
	\end{tabular}
	\caption{Tock Tree API. Note that we deliberately avoid dictating what node get uncomputed, in order to decouple uncomputation/recomputation with selecting what to uncompute. Instead, node might be dropped during insertion into TockTree. One might e.g. set a limit onto the amount of nodes in the Tock Tree. }
\end{figure}

\subsection{Replay Continuation}
\begin{figure}
\begin{tabular}{p{10em} p{2.6em} p{1em} p{0.45\textwidth}}
	ReplayContinuation & RK & ::= & NoReplay | RKApply V Tock RK | \\
	& & & RKCase Tock Env N E N E K RK | \\
	& & & RKZro Tock K RK | RKFst Tock K RK \\
	Replay & R & ::= & (State, RK) \\
\end{tabular}
\end{figure}
\begin{figure}
\begin{mathpar}
	\inferrule{ }{RApply: (Tock, Node, RK) \to (State, RK)}
	
	\inferrule{ }{RApply (\_, (\_, st), NoReplay) = (st, NoReplay)}
	
	\inferrule{ }{RApply (\_, (\Nothing, st), rk) = (st, rk)}
	
	\inferrule{ t + 1 != t' }{\RApply((t, \Just~ cell, st), rk) = (st, rk)}
	
	\inferrule{ t + 1 = t' }{\RApply((t, \Just~ cell, st), \RKApply~ v t' rk) = (\Apply~ v cell t', rk)}
	
	\inferrule{ t + 1 = t' }{\RApply((t, \Just~ \VLeft X, st), RKCase~ t'~ Env~ LN~ L~ RN~ R~ K~ RK) = ((\Eval~ L~ Env[LN := X] K, t'), rk)}
	
	\inferrule{ t + 1 = t' }{\RApply((t, \Just~ \VRight X, st), RKCase~ t'~ Env~ LN~ L~ RN~ R~ K~ RK) = (\Eval~ R~ Env[RN := Y] K t', rk)}
	
	\inferrule{ t + 1 = t' }{\RApply((t, \Just~ \VProd~ X~ Y, st), RKZro~ t'~ K~ RK) = (\Apply~ X~ K~ t', RK)}
	
	\inferrule{ t + 1 = t' }{\RApply((t, \Just~ \VProd~ X~ Y, st), RKFst~ t'~ K~ RK) = (\Apply~ Y~ K~ t', RK)}
\end{mathpar}

\end{figure}
\begin{mathpar}
	FromTock: (TockTree, Tock) -> VCell | KCell | State
	From The tock tree, try to get the corresponding cell.
	If the cell is uncomputed, return the closest state that can recompute it.
	
	FromTock(tt, t) = 
	let (Node cells state, nt) = query(tt, t) in
	if nt + 1 <= t < nt + 1 + len(cells) then cells[t - nt - 1] else state
	
	goto: (Replay, TockTree) -> (Replay, TockTree)
	State = Step Expr Env K | Apply K V
\end{mathpar}
\begin{mathpar}
	Apply(P, V) = apply(Lookup(P), V)
	apply(KLeft K, V), H goto Apply(K, P), H' where (P, H') = Alloc(VLeft V, H)
	
	apply(KRight K, V), H goto Apply(K, P), H' where (P, H') = Alloc(VRight V, H)
	
	apply(KCase Env LN L RN R K, V), H goto 
	if LookUp(V, H) = VLeft V then Step(L, Env(LN := V), K)
	= VRight V then Step(R, Env(RN := V), K)
	
	apply(KProd0 Env R K, V), H goto Step(R, Env, P), H' where (P, H') = Alloc(KProd1 V Env K, H)
	
	apply(KProd1 L K, V), H goto Apply(P, K), H' where (P, H') = Alloc(VProd L V, H)
	
	apply(KZro K, V), H goto Apply(X, K), H where VProd X Y = LookUp(V, H)
	
	apply(KFst K, V), H goto Apply(Y, K), H where VProd X Y = LookUp(V, H)
	
	apply(KLet A Env C K, B), H goto Step(C, Env(A := B), K), H
	
	apply(KApp0 Env X K, V) goto Step(X, Env, P) where (P, H'), H' = Alloc(KApp1 V K, H)
	
	apply(KApp1 F K, V), H goto Step(E, Env(N := V), K), H where (Clos Env N E) = LookUp(V, H)
\end{mathpar}
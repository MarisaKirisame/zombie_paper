\section{CEKR Machine}
In this section we formalize the semantic of the language with uncomputation and recomputation. It is implemented by adding a Replay Continuation alongside the CEK Machine.
Hence we call it the CEKR Machine.

\subsection{Tock Tree}
\begin{figure}
	\begin{tabular}{p{4em} p{2.6em} p{10em} p{1em} p{0.45\textwidth}}
	before & $:$ & Value & = & P<VCell> \\
	after & $:$ & Value & = & Tock \\
	before & $:$ & Continuation & = & P<KCell> \\
	after & $:$ & Continuation & = & Tock \\
	before & $:$ & State & ::= & $\Eval~E~\Env~K \mid \Apply~K~V $ \\
	after & $:$ & State & ::= & $\Eval~E~\Env~K~Tock \mid \Apply~K~V~Tock $ \\
	Node & & & = & (Maybe(KCell | VCell), State) \\
	Query & $:$ & (TockTree, Tock) & -> & (Tock, Node) \\
	Insert & $:$ & (TockTree, Tock, Node) & -> & TockTree \\
	\end{tabular}
	\caption{Tock Tree API. Note that we deliberately avoid dictating what node get uncomputed, in order to decouple uncomputation/recomputation with selecting what to uncompute. Instead, node might be dropped during insertion into TockTree. One might e.g. set a limit onto the amount of nodes in the Tock Tree. }
\end{figure}

\subsection{Replay Continuation}
\begin{figure}
\begin{tabular}{p{10em} p{2.6em} p{1em} p{0.45\textwidth}}
	ReplayContinuation & RK & ::= & NoReplay | RKApply V Tock RK | \\
	& & & RKCase Tock Env N E N E K RK | \\
	& & & RKZro Tock K RK | RKFst Tock K RK | \\
	& & & RKApp Tock Env E K RK \\
	Replay & R & ::= & (State, RK) \\
\end{tabular}
\end{figure}
\begin{figure}
	\begin{mathpar}
		\inferrule{ }{RApply: (Tock, Node, RK) \to (State, RK)}
		
		\inferrule{ }{RApply (\_, (\_, st), NoReplay) = (st, NoReplay)}
		
		\inferrule{ }{RApply (\_, (\Nothing, st), rk) = (st, rk)}
		
		\inferrule{ t + 1 != t' }{\RApply((t, \Just~ cell, st), rk) = (st, rk)}
		
		\inferrule{ t + 1 = t' }{\RApply((t, \Just~ cell, st), \RKApply~ v t' rk) = (\Apply~ v cell t', rk)}
		
		\inferrule{ t + 1 = t' }{\RApply((t, \Just~ \VLeft X, st), RKCase~ t'~ Env~ LN~ L~ RN~ R~ K~ RK) = ((\Eval~ L~ Env[LN := X] K, t'), rk)}
		
		\inferrule{ t + 1 = t' }{\RApply((t, \Just~ \VRight X, st), RKCase~ t'~ Env~ LN~ L~ RN~ R~ K~ RK) = (\Eval~ R~ Env[RN := Y] K t', rk)}
		
		\inferrule{ t + 1 = t' }{\RApply((t, \Just~ \VProd~ X~ Y, st), RKZro~ t'~ K~ RK) = (\Apply~ X~ K~ t', RK)}
		
		\inferrule{ t + 1 = t' }{\RApply((t, \Just~ \VProd~ X~ Y, st), RKFst~ t'~ K~ RK) = (\Apply~ Y~ K~ t', RK)}

		\inferrule{ t + 1 = t' }{\RApply((t, \Just~ \Clos \Env'~ N~ E, st), RKApp~ t'~ \Env~ X~ K RK) = (\Eval X~ \Env~ (\KApp1 \Env' N E K), RK)}
	\end{mathpar}
\end{figure}

\begin{figure}
\begin{mathpar}
	\inferrule{ }{(\text{State}, rk), TockTree \leadsto (\text{State}, rk), TockTree} \and
	\inferrule{st = \Apply(K, \Env(N), t+1) \and node = (Nothing, st) \and TT' = insert(TT, t, node) }{(\Eval(N, \Env, K, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KLeft~K, st) \and TT' = insert(TT, t, node)}{(\Eval(\sLeft~X, \Env, K, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KRight~K, st) \and TT' = insert(TT, t, node)}{(\Eval(\sRight~X, \Env, K, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KProd_0~K~R, st) \and TT' = insert(TT, t, node)}{(\Eval(\sProd~L~R, \Env, K, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KZro~K, st) \and TT' = insert(TT, t, node)}{(\Eval(\sZro~X, \Env, K, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KFst~K, st) \and TT' = insert(TT, t, node)}{(\Eval(\sFst~X, \Env, K, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KCase~\mathit{LN}~L~\mathit{RN}~R~\Env, st) \and TT' = insert(TT, t, node)}{(Eval(\sCase~X~\mathit{LN}~L~\mathit{RN}~R, \Env, K, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KLet~A~K~C~\Env, st) \and TT' = insert(TT, t, node)}{(\Eval(\sLet~A~B~C, \Env, K, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KApp_0~K~X, st) \and TT' = insert(TT, t, node)}{(\Eval(\sApp~F~X, \Env, K, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \Clos~\Env(\text{fv})\cdots N~E, st) \and TT' = insert(TT, t, node)}{(\Eval(\sLam~N~E, \Env, K, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
\end{mathpar}
\end{figure}
\begin{figure}
\begin{mathpar}
	\inferrule{Query(tt, K) = (X, (\_, st)) \and X != K - 1}{(Apply(K, V, t), rk), TT \leadsto (st, RKApply~ V~ k~ rk), TT} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KLeft K', \_)) \and st = \Apply(K', t+1, t+2) \and node = (\Just~ VLeft V, st) \and TT' = insert(TT, t, node)}{(Apply(K, V, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KRight K', \_)) \and st = \Apply(K', t+1, t+2) \and node = (\Just~ VRight V, st) \and TT' = insert(TT, t, node)}{(Apply(K, V, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KCase Env LN L RN R K', \_)) \and Query(tt, V) = (X, (\_, st)) \and X != V - 1}{(Apply(K, V, t), rk), TT \leadsto (st, RKCase~ V~ Env LN L RN R K' rk), TT} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KCase Env LN L RN R K', \_)) \and Query(tt, V) = (V-1, (\Just~ VLeft X, \_)) \and st = \Eval(L, \Env[LN := X], K', t+1) \and node = (Nothing, st) \and TT' = insert(TT, t, node)}{(Apply(K, V, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KCase Env LN L RN R K', \_)) \and Query(tt, V) = (V-1, (\Just~ VRight X, \_)) \and st = \Eval(R, \Env[RN := X], K', t+1) \and node = (Nothing, st) \and TT' = insert(TT, t, node)}{(Apply(K, V, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KProd0 Env R K', \_)) \and st = \Eval(R, Env, t+1, t+2) \and node = (Just KProd1 V Env K', st) \and TT' = insert(TT, t, node)}{(Apply(K, V, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KProd1 L K', \_)) \and st = \Apply(K', t+1, t+2) \and node = (Just VProd L V, st) \and TT' = insert(TT, t, node)}{(Apply(K, V, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KZro K', \_)) \and Query(tt, V) = (X, (\_, st)) \and X != V - 1}{(Apply(K, V, t), rk), TT \leadsto (st, RKZro~ V~ K' rk), TT} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KZro K', \_)) \and Query(tt, V) = (V-1, (VProd X Y, \_)) \and st = \Apply(K', X, t+1) \and node = (Nothing, st) \and TT' = insert(TT, t, node)}{(Apply(K, V, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KFst K', \_)) \and Query(tt, V) = (X, (\_, st)) \and X != V - 1}{(Apply(K, V, t), rk), TT \leadsto (st, RKFst~ V~ K' rk), TT} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KFst K', \_)) \and Query(tt, V) = (V-1, (VProd X Y, \_)) \and st = \Apply(K', Y, t+1) \and node = (Nothing, st) \and TT' = insert(TT, t, node)}{(Apply(K, V, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KLet A Env C K', \_)) \and st = \Eval(C, Env[A := V], K', t+1) \and node = (Nothing, st) \and TT' = insert(TT, t, node)}{(Apply(K, V, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KApp0 Env X K', \_)) \and Query(tt, V) = (X', (\_, st)) \and X' != V - 1}{(Apply(K, V, t), rk), TT \leadsto (st, RKApply~ V~ \Env~ X K'~ rk), TT} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KApp0 Env X K', \_)) \and Query(tt, V) = (V-1, (Clos Env' N E), \_), st = \Eval(X, Env, t+1, t+2) \and node = (Just KApp1 Env' N E K', st) \and TT' = insert(TT, t, node)}{(Apply(K, V, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
	\inferrule{Query(tt, K) = (K-1, (\Just~ KApp1 Env N E K', \_)) \and st = \Eval(E, Env[N := V], K', t+1) \and node = (Nothing, st) \and TT' = insert(TT, t, node)}{(Apply(K, V, t), rk), TT \leadsto \RApply(t, node, rk), TT'} \and
\end{mathpar}
\end{figure}
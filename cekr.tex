\section{CEKR Machine}
In this section we formalize the semantic of the language with uncomputation and recomputation. It is implemented by adding a Replay Continuation alongside the CEK Machine.
Hence we call it the CEKR Machine.

\subsection{Tock Tree}
\begin{figure}
	\begin{tabular}{p{4em} p{2.6em} p{10em} p{1em} p{0.45\textwidth}}
	before & $:$ & Value & = & P<VCell> \\
	after & $:$ & Value & = & Tock \\
	before & $:$ & Continuation & = & P<KCell> \\
	after & $:$ & Continuation & = & Tock \\
	before & $:$ & State & ::= & $\Eval~E~\Env~K \mid \Apply~K~V $ \\
	after & $:$ & State & ::= & $\Eval~E~\Env~K~Tock \mid \Apply~K~V~Tock $ \\
	Node & & & = & (Maybe(KCell | VCell), State) \\
	Query & $:$ & (TockTree, Tock) & -> & (Tock, Node) \\
	Insert & $:$ & (TockTree, Tock, Node) & -> & TockTree \\
	\end{tabular}
	\caption{Tock Tree API. Note that we deliberately avoid dictating what node get uncomputed, in order to decouple uncomputation/recomputation with selecting what to uncompute. Instead, node might be dropped during insertion into TockTree. One might e.g. set a limit onto the amount of nodes in the Tock Tree. }
\end{figure}

\subsection{Replay Continuation}
\begin{figure}
\begin{tabular}{p{10em} p{2.6em} p{1em} p{0.45\textwidth}}
	ReplayContinuation & RK & ::= & NoReplay | Replaying Tock RH RK | \\
	ReplayHole & RH & ::= & RHLookup V Tock | \\
	& & & RHCase Env N E N E K Tock | \\
	& & & RHZro K Tock | RKFst K Tock | \\
	& & & RHApp Env E K Tock \\
	Replay & R & ::= & (State, RK) \\
\end{tabular}
\end{figure}

\begin{figure}
\begin{mathpar}
	\inferrule{ }{(\text{State} | Return~ Cell), rk, TockTree \leadsto (\text{State} | Return~ Cell), rk, TockTree} \and

	\inferrule{ }{CheckReturn(t, (\Nothing, st), rk) = st} \and
	\inferrule{t + 1 != t'}{CheckReturn(t, (\_, st), \NoReplay) = st} \and
	\inferrule{ }{CheckReturn(t, (\Just~ cell, st), \Replaying (t + 1) rh rk) = Return~ cell} \and
	\inferrule{t + 1 != t'}{CheckReturn(t, (\Just~ cell, st), \Replaying t' rh rk) = st} \and

	\inferrule{ }{PostProcess(t, node, rk, tt) = CheckReturn(t, node, rk), rk, insert(tt, t, node)}

	\inferrule{st = \Apply(cell, v, (t + 1)) \and node = (\Nothing, st)}{Return~ cell, \Replaying~ \_ (RHLookup~ v~ t) rk, tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Eval(L, \Env[LN := X], K, (t + 1)) \and node = (\Nothing, st) \and}{Return~ (\VLeft X), \Replaying~ \_ (RHCase~ \Env~ LN~ L~ RN~ R~ K~ t), tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Eval(R, \Env[RN := Y], K, (t + 1)) \and node = (\Nothing, st)}{Return~ (\VRight Y), \Replaying~ \_ (RHCase~ \Env~ LN~ L~ RN~ R~ K~ t), tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Apply(K, X, (t + 1)) \and node = (\Nothing, st)}{Return~ (\VProd~ X~ Y), \Replaying~ \_ (RHZro~ K~ t), tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Apply(K, Y, (t + 1)) \and node = (\Nothing, st)}{Return~ (\VProd~ X~ Y), \Replaying~ \_ (RHFst~ K~ t), tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Eval(X, \Env~, (t + 1), (t + 2)) \and node = (\Just(\KApp1 \Env' N E K), st)}{Return~ (\Clos \Env'~ N~ E), \Replaying~ \_ (RHApp~ \Env~ X~ K~ t), tt \leadsto PostProcess(t, node, rk, tt)} \and	
\end{mathpar}
	\caption{CEKR transition: Return}
\end{figure}
\begin{figure}
\begin{mathpar}
	\inferrule{Query(tt, K) = (K - 1, \Just kcell) \and st = \Apply(kcell, N, t + 1) \and node = (\Nothing, st)}{\Eval(N, \Env, K, t), rk, tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{Query(tt, K) = (X, st) \and X != K - 1}{\Eval(N, \Env, K, t), rk, tt \leadsto st, \Replaying~ K (RHLookup~ N~ t) rk, tt} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KLet~A~K~C~\Env, st)}{(\Eval(\sLet~A~B~C, \Env, K, t), rk), tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \Clos~\Env(\text{fv})\cdots N~E, st)}{(\Eval(\sLam~N~E, \Env, K, t), rk), tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KApp_0~\Env~X~K, st)}{(\Eval(\sApp~F~X, \Env, K, t), rk), tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KProd_0~K~R, st)}{(\Eval(\sProd~L~R, \Env, K, t), rk), tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KZro~K, st)}{(\Eval(\sZro~X, \Env, K, t), rk), tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KFst~K, st)}{(\Eval(\sFst~X, \Env, K, t), rk), tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KLeft~K, st)}{(\Eval(\sLeft~X, \Env, K, t), rk), tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KRight~K, st)}{(\Eval(\sRight~X, \Env, K, t), rk), tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Eval(X, \Env, t+1, t+2) \and node = (\Just~ \KCase~\mathit{LN}~L~\mathit{RN}~R~\Env, st)}{(Eval(\sCase~X~\mathit{LN}~L~\mathit{RN}~R, \Env, K, t), rk), tt \leadsto PostProcess(t, node, rk, tt)} \and
\end{mathpar}
	\caption{CEKR Transition: Eval}
\end{figure}
\begin{figure}
\begin{mathpar}
	\inferrule{Query(tt, K) = (X, (\_, st)) \and X != K - 1}{\Apply(\KLookup K, V, t, rk), tt \leadsto st, \Replaying~ K~ (RHLookup V t) rk, tt} \and
	\inferrule{Query(tt, K) = (K - 1, (\Just cell, \_)) \and st = \Apply(cell, V, t+1) \and node = (\Nothing, st)}{\Apply(\KLookup K, V, t), rk, tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Eval(C, Env[A := V], K', t+1) \and node = (Nothing, st) }{\Apply(\KLet~ A~ \Env~ C~ K', V, t), rk, tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{Query(tt, V) = (X', (\_, st)) \and X' != V - 1}{(Apply(\Just~ KApp0 Env X K, V, t), rk), tt \leadsto st, \Replaying V (RHApp Env X K t) rk, tt} \and
	\inferrule{Query(tt, V) = (V - 1, (\Clos Env' N E), \_) \and st = \Eval(X, Env, t+1, t+2) \and node = (\Just KApp1 \Env' N E K', st)}{\Apply(\KApp0~ \Env~ X~ K', V, t), rk, tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Eval(E, Env[N := V], K', t+1) \and node = (Nothing, st)}{\Apply(\KApp1 Env N E K', V, t), rk, tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Eval(R, Env, t+1, t+2) \and node = (\Just KProd1 V Env K, st)}{\Apply(KProd0 Env R K, V, t), rk, tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Apply(K, t+1, t+2) \and node = (\Just \VProd L V, st)}{Apply(KProd1 L K, V, t), rk, TT \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{Query(tt, V) = (X, (\_, st)) \and X != V - 1}{Apply(KZro K, V, t), rk, tt \leadsto st, \Replaying~ V~ (RHZro K t) rk, tt} \and
	\inferrule{Query(tt, V) = (V - 1, (VProd X Y, \_)) \and st = \Apply(K, X, t+1) \and node = (\Nothing, st)}{Apply(KZro K, V, t), rk, tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{Query(tt, V) = (X, (\_, st)) \and X != V - 1}{\Apply(KFst K, V, t), rk, tt \leadsto st, \Replaying~ V~ (RHFst K t) rk, tt} \and
	\inferrule{Query(tt, V) = (V - 1, (VProd X Y, \_)) \and st = \Apply(K, Y, t+1) \and node = (Nothing, st)}{\Apply(KFst K, V, t), rk, tt \leadsto PostProcess(t, node, rk, tt)} \and
\end{mathpar}
\caption{CEKR Transition: Apply}
\end{figure}
\begin{figure}
\begin{mathpar}
	\inferrule{st = \Apply(K, t+1, t+2) \and node = (\Just~ VLeft V, st)}{\Apply(KLeft K, V, t), rk, tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{st = \Apply(K, t+1, t+2) \and node = (\Just~ VRight V, st)}{\Apply(KRight K, V, t), rk, tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{Query(tt, V) = (X, (\_, st)) \and X != V - 1}{\Apply(KCase Env LN L RN R K, V, t), rk, tt \leadsto st, \Replaying V (RHCase Env LN L RN R K t) rk), tt} \and
	\inferrule{Query(tt, V) = (V - 1, (\Just~ VLeft X, \_)) \and st = \Eval(L, \Env[LN := X], K', t+1) \and node = (Nothing, st)}{Apply(KCase Env LN L RN R K, V, t), rk, tt \leadsto PostProcess(t, node, rk, tt)} \and
	\inferrule{Query(tt, V) = (V - 1, (\Just~ VRight Y, \_)) \and st = \Eval(R, \Env[RN := Y], K', t+1) \and node = (Nothing, st)}{Apply(KCase Env LN L RN R K, V, t), rk, tt \leadsto PostProcess(t, node, rk, tt)} \and
\end{mathpar}
	\caption{CEKR Transition: Apply}
\end{figure}